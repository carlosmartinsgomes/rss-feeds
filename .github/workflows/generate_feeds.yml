name: Generate RSS feeds (stable + businesswire)

on:
  push:
    branches: [ main ]
  workflow_dispatch:
  schedule:
    - cron: '*/30 * * * *'

env:
  PYTHON_VERSION: '3.11'
  NODE_VERSION: '18'

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Show repo root (debug)
        run: |
          echo "GITHUB_WORKSPACE=$GITHUB_WORKSPACE"
          pwd
          ls -la

      - name: Detect scripts dir
        id: detect
        run: |
          if [ -d "./scripts" ]; then sd="scripts";
          elif [ -d "./rss-feeds/scripts" ]; then sd="rss-feeds/scripts";
          else sd=$(find . -type d -name scripts | head -n 1); sd="${sd#./}";
          fi
          echo "scripts_dir=$sd" >> $GITHUB_OUTPUT
          echo "Detected scripts_dir: $sd"
          if [ -n "$sd" ] && [ -f "$sd/sites.json" ]; then
            echo "sites.json exists at $sd/sites.json"
          else
            echo "sites.json not found at $sd/sites.json"
          fi

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install playwright into scripts (npm --prefix) and chromium
        if: steps.detect.outputs.scripts_dir != ''
        run: |
          SCRIPTS="${{ steps.detect.outputs.scripts_dir }}"
          echo "Installing playwright into $SCRIPTS (npm --prefix)..."
          npm install --prefix "$SCRIPTS" playwright --no-audit --no-fund --silent || { echo "npm install failed"; exit 1; }
          echo "Installing chromium browser (playwright) into $SCRIPTS (npx --prefix)..."
          npx --yes --prefix "$SCRIPTS" playwright install chromium || { echo "playwright browser install failed"; exit 1; }
          echo "Done playwright install."

      - name: Verify playwright is importable (sanity)
        if: steps.detect.outputs.scripts_dir != ''
        run: |
          SCRIPTS="${{ steps.detect.outputs.scripts_dir }}"
          echo "Node version: $(node --version)"
          echo "NPM version: $(npm --version)"
          echo "Listing $SCRIPTS/node_modules top entries:"
          ls -la "$SCRIPTS/node_modules" | sed -n '1,200p' || true
          node -e "try { require('./${{ steps.detect.outputs.scripts_dir }}/node_modules/playwright'); console.log('playwright ok'); } catch(e) { console.error('playwright require failed:', e.message); process.exit(2); }"

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install Python deps
        run: |
          python -m pip install --upgrade pip
          if [ -f "requirements.txt" ]; then
            pip install -r requirements.txt
          else
            pip install requests beautifulsoup4 feedgen lxml
          fi

      - name: Render pages that need JS (explicit list, incl. BusinessWire)
        run: |
          SCRIPTS="${{ steps.detect.outputs.scripts_dir }}"
          if [ -z "$SCRIPTS" ]; then
            echo "No scripts dir detected -> skip rendering"
            exit 0
          fi
          mkdir -p "$SCRIPTS/rendered"
          # Explicit render targets (BusinessWire pages included) - ONLY these URLs
          RENDER_TARGETS=(
            "https://inmodeinvestors.com/press-release|$SCRIPTS/rendered/inmode-press.html"
            "https://www.darkreading.com/|$SCRIPTS/rendered/darkreading.html"
            "https://www.iotworldtoday.com/|$SCRIPTS/rendered/iotworldtoday.html"
            "https://www.businesswire.com/newsroom|$SCRIPTS/rendered/businesswire-page1.html"
            "https://www.businesswire.com/newsroom?page=2|$SCRIPTS/rendered/businesswire-page2.html"
            "https://www.businesswire.com/newsroom?page=3|$SCRIPTS/rendered/businesswire-page3.html"
            "https://www.businesswire.com/newsroom?page=4|$SCRIPTS/rendered/businesswire-page4.html"
            "https://www.businesswire.com/newsroom?page=5|$SCRIPTS/rendered/businesswire-page5.html"
          )
          for pair in "${RENDER_TARGETS[@]}"; do
            url="${pair%%|*}"
            out="${pair##*|}"
            echo "Attempting render: $url -> $out"
            if [ ! -f "$SCRIPTS/render_page.js" ]; then
              echo "render_page.js not found at $SCRIPTS/render_page.js - skipping render for $url"
              continue
            fi
            # Allow render_page.js to decide quick-get vs playwright; log failures but continue
            node "$SCRIPTS/render_page.js" "$url" "$out" || echo "render failed for $url"
          done
          echo "Rendered dir listing:"
          ls -la "$SCRIPTS/rendered" || true

      - name: Render configured pages (for sites with render_file) - WHITELISTED hosts only
        env:
          # lista explícita (se quiseres bloquear duplicação): mantive vazia porque a etapa explícita já fez esses
          EXPLICIT_URLS: |
            https://inmodeinvestors.com/press-release
            https://www.darkreading.com/
            https://www.iotworldtoday.com/
            https://www.businesswire.com/newsroom
            https://www.businesswire.com/newsroom?page=2
            https://www.businesswire.com/newsroom?page=3
            https://www.businesswire.com/newsroom?page=4
            https://www.businesswire.com/newsroom?page=5
        run: |
          SCRIPTS="${{ steps.detect.outputs.scripts_dir }}"
          echo "Using SCRIPTS='$SCRIPTS' and EXPLICIT_URLS provided"

          node <<'NODE'
          const fs = require('fs');
          const cp = require('child_process');
          const path = require('path');

          // WHITELIST: apenas estes hosts serão processados por este passo
          const allowedHosts = [
            'dzone.com',
            'eetimes.com',
            'mdpi.com',
            'medscape.com',
            'stocktwits.com',
            'journals.lww.com'
          ];

          function hostOf(urlString) {
            try {
              const u = new URL(urlString);
              return (u.hostname || '').toLowerCase().replace(/^www\./,'');
            } catch (e) {
              const m = String(urlString || '').toLowerCase().match(/:\/\/([^\/:?#]+)/);
              return m ? m[1].replace(/^www\./,'') : '';
            }
          }

          function hostMatchesAllowed(hostname) {
            if (!hostname) return false;
            return allowedHosts.some(a => hostname === a || hostname.endsWith('.' + a));
          }

          // read env provided by the step
          let scriptsDir = process.env.SCRIPTS || '';
          const explicitRaw = process.env.EXPLICIT_URLS || '';
          const explicit = explicitRaw.split(/\r?\n/).map(s => s.trim()).filter(Boolean);

          const candidates = ['scripts', 'rss-feeds/scripts', './scripts', './rss-feeds/scripts'];
          if (!scriptsDir) {
            for (const c of candidates) {
              try {
                if (fs.existsSync(path.join(c, 'sites.json')) && fs.existsSync(path.join(c, 'render_page.js'))) {
                  scriptsDir = c;
                  break;
                }
              } catch (e) { /* ignore */ }
            }
          }

          if (!scriptsDir) {
            console.warn('Could not determine scripts directory. Skipping configured renders.');
            process.exit(0);
          }

          scriptsDir = scriptsDir.replace(/\/+$/,'');
          const sitesFile = path.join(scriptsDir, 'sites.json');
          if (!fs.existsSync(sitesFile)) {
            console.warn(`sites.json not found at ${sitesFile} -> skipping configured renders`);
            process.exit(0);
          }

          let sites = [];
          try {
            const raw = fs.readFileSync(sitesFile, 'utf8');
            sites = JSON.parse(raw).sites || [];
          } catch (e) {
            console.error('Failed to read/parse sites.json:', e && e.message ? e.message : e);
            process.exit(0);
          }

          const renderScript = path.join(scriptsDir, 'render_page.js');
          if (!fs.existsSync(renderScript)) {
            console.warn(`render_page.js not found at ${renderScript} -> skipping`);
            process.exit(0);
          }

          try { fs.mkdirSync(path.join(scriptsDir, 'rendered'), { recursive: true }); } catch(e){}

          for (const s of sites.filter(s => s.render_file)) {
            const urlRaw = (s.url || '').trim();
            if (!urlRaw) continue;
            const host = hostOf(urlRaw);

            // se não estiver na whitelist, ignora
            if (!hostMatchesAllowed(host)) {
              console.log('Skipping (not in configured whitelist):', urlRaw);
              continue;
            }

            // se a URL já foi explicitamente tratada na etapa explícita, pula para evitar duplicação
            if (explicit.includes(urlRaw)) {
              console.log('Skipping configured render for (explicit handled):', urlRaw);
              continue;
            }

            const url = urlRaw;
            const out = s.render_file;
            console.log('Rendering', url, '->', out);
            try {
              const cmd = `node "${renderScript}" "${String(url).replace(/"/g,'\\"')}" "${String(out).replace(/"/g,'\\"')}"`;
              cp.execSync(cmd, { stdio: 'inherit', timeout: 180000 });
              console.log('-> Done:', url);
            } catch (err) {
              console.error('Render failed for', url, '-', err && err.message ? err.message : err);
            }
          }
          NODE

      - name: Run feed generator (Python)
        run: |
          SCRIPTS="${{ steps.detect.outputs.scripts_dir }}"
          if [ -f "${SCRIPTS}/generate_feeds.py" ]; then
            python3 "${SCRIPTS}/generate_feeds.py"
          elif [ -f "scripts/generate_feeds.py" ]; then
            python3 scripts/generate_feeds.py
          else
            echo "generate_feeds.py not found -> abort"
            exit 1
          fi

      - name: Show produced feeds
        run: |
          echo "Feeds dir listing:"
          ls -la feeds || true
          for f in feeds/*.xml; do
            echo "---- $f ----"
            head -n 40 "$f" || true
          done
